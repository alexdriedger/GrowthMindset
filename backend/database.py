from urllib import parse  # pylint: disable=no-name-in-module
import psycopg2  # pylint: disable=import-error
import pandas as pd  # pylint: disable=import-error
import json

DATABASE_URL = "postgres://munfzpuxgvkogi:" \
               "094596dafa9e38305a839455b1829555651f126c3aa93b10069f8ac7b664fffd" \
               "@ec2-50-19-105-113.compute-1.amazonaws.com:5432/dd5dl7lpfor3a4"

connection = None
cursor = None

"""
This Database class wraps a SQL database with utility functions
that are exposed to our main app. This abstraction makes interacting with the Database
very easy and allows us to change the database if necessary.
"""
#def __init__(self, test=False):
    #Database.get_conn_and_cursor()
    # self.test = test
    #
    # connection, cursor = Database.get_conn_and_cursor()
    # # Drop and re-create the table if we are in testing mode, otherwise the data should be preserved
    #
    # if self.test:
    #     cursor.execute("DROP TABLE IF EXISTS events;")
    #     print("Dropped table 'events'")
    # cursor.execute("CREATE TABLE IF NOT EXISTS events ("
    #                     "list_id text PRIMARY KEY,"  # A UUID for each event. Generated by clients
    #                     "available_list text[],"  # An array of available times
    #                     "creator_code text,"  # An ID for the creator of the event
    #                     "duration bigint,"  # The duration of the event
    #                     "email_creator text,"  # The email of the creator of the event
    #                     "email_responder text,"  # The email of the recipient of the event
    #                     "location text,"  # The name of the location of the event
    #                     "summary text,"  # The summary of the event
    #                     "description text);")  # The description of the event
    # connection.close()

def get_conn_and_cursor(test=False):
    """
    Constructs a new Databse instance, pointing at the postgres databse
    hosted on heroku
    """
    parse.uses_netloc.append("postgres")

    global connection
    if connection is None:
        # If the database is to be created for deployment, use the url that points to the database
        # hosted on Heroku
        url = parse.urlparse(DATABASE_URL)
        connection = psycopg2.connect(
            database=url.path[1:],
            user=url.username,
            password=url.password,
            host=url.hostname,
            port=url.port
        )
        print("Database initialized for deployment")
        print("Creating new database connection")

    global cursor
    if cursor is None:
        cursor = connection.cursor()


    cursor.execute("CREATE TABLE IF NOT EXISTS events ("
                   "list_id text PRIMARY KEY,"  # A UUID for each event. Generated by clients
                   "available_list text[],"  # An array of available times
                   "creator_code text,"  # An ID for the creator of the event
                   "duration bigint,"  # The duration of the event
                   "email_creator text,"  # The email of the creator of the event
                   "email_responder text,"  # The email of the recipient of the event
                   "location text,"  # The name of the location of the event
                   "summary text,"  # The summary of the event
                   "description text);")  # The description of the event

    # return (connection, cursor)


def create_event(list_id, available_list, creator_code, duration, email_creator, email_responder, location, summary, description):
    """
    Creates a new event in the database, using the given parameters
    :param list_id: A unique String ID for each event. Generated by clients
    :param available_list: An array of strings representing available times
    :param creator_code: A string ID for the creator of the event
    :param duration: A positive interger representing the duration of the event
    :param email_creator: A string containing the email of the creator of the event
    :param email_responder: A string containing the email of the recipient of the event
    :param location: A string containing the name of the location for the event
    :param summary: A string containing the summary of the event
    :param description: A string containing the description of the event
    :return: True if the event was created successfully and False otherwise
    """
    get_conn_and_cursor()

    # TODO: Add checks for duplicate entries / duplicate list_ids
    try:
        cursor.execute("INSERT INTO events"
                            "(list_id, available_list, creator_code, duration, email_creator, email_responder, location, summary, description) "
                            "VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s);",
                            (list_id, available_list, creator_code, duration, email_creator, email_responder, location, summary, description))
    except Exception:
        print("Fa1iled to create event with list_id: {}. Event already exists".format(list_id))
        # connection.close()
        return False

    # connection.close()
    return True

def delete_event(list_id):
    """
    Deletes the event with the given list_id. This list_id should be unique so no more than 1 event
    should be deleted
    :param list_id: The list_id of the event to delete
    :return: True if the event was deleted successfully and False otherwise
    """
    get_conn_and_cursor()

    try:
        # The comma next to list_id needs to be there to form a tuple
        cursor.execute("DELETE FROM events "
                            "WHERE list_id = (%s);", (list_id,))
        print("Deleted event")
    except Exception:
        # TODO: Why is this not reached?
        print("Failed to delete the event with list_id: {} from events. Item does not exist".format(list_id))
        # connection.close()
        return False

    # connection.close()
    return True

def get_events_by_email_responder(email_responder):
    """
    Returns all events that need to be responded to by the given email. The events are returned in JSON format.
    :param email_responder: The email of the events to be returned
    :return: A JSON object containing all events with the given email. If no such events are in the databse, a
    JSON string containing an empty list is returned
    """
    get_conn_and_cursor()

    # The comma next to list_id needs to be there to form a tuple
    cursor.execute("SELECT * FROM events "
                        "WHERE email_responder = (%s);", (email_responder,))
    events = []
    try:
        events = cursor.fetchall()
    except Exception:  # normally throws ProgrammingError
        pass

    # selfconnection.close()
    return json.dumps(events)

def get_events_by_email_creator(email_creator):
    """
    Returns all events that were created by the given email. The events are returned in JSON format.
    :param email_creator: The email of the events to be returned
    :return: A JSON object containing all events with the given email. If no such events are in the databse, a
    JSON string containing an empty list is returned
    """
    get_conn_and_cursor()

    # The comma next to list_id needs to be there to form a tuple
    cursor.execute("SELECT * FROM events "
                        "WHERE email_creator = (%s);", (email_creator,))
    events = []
    try:
        events = cursor.fetchall()
    except Exception:  # normally throws ProgrammingError
        pass

    # connection.close()
    return json.dumps(events)

def get_events_by_id(list_id):
    """
    Returns the event that contains the given list_id. The events are returned in JSON format.
    :param list_id: The list_id of the event to be returned
    :return: A JSON object the event with the given list_id. If no such event is in the databse, a
    JSON string containing an empty list is returned
    """
    get_conn_and_cursor()

    # The comma next to list_id needs to be there to form a tuple
    cursor.execute("SELECT * FROM events "
                        "WHERE list_id = (%s);", (list_id,))
    events = []
    try:
        events = cursor.fetchall()
    except Exception:  # normally throws ProgrammingError
        pass

    # connection.close()
    return json.dumps(events)

def getall():
    """
    Gets the table for testing purposes
    """
    get_conn_and_cursor()
    ret = pd.read_sql('select * from events;', connection)
    # connection.close()
    return ret

def printall(): #pragma: no cover
    """
    Prints the table for testing purposes
    """
    get_conn_and_cursor()
    my_table = pd.read_sql('select * from events;', connection)
    # connection.close()
    print(my_table)  # pylint: disable=superfluous-parens
    print("\n\n\n\n")

# initialize the db
get_conn_and_cursor()
